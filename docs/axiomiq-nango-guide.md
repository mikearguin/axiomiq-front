# AxiomIQ: Nango OAuth Integration Guide

## What is Nango?

Nango is a complete infrastructure for engineers to build product integrations. It provides embedded, white-label auth UI with appropriate input forms and guidance, secure credential management with retrieval, storage, and refreshing of API credentials, credential monitoring that notifies via webhooks when credentials become invalid, and request proxying that injects credentials into API requests seamlessly.

**Why Nango for AxiomIQ?**
- Your customers will connect their Gmail, Slack, HubSpot, etc. to power their workflows
- Nango handles all the OAuth complexity (token refresh, expiration, re-auth)
- We went from zero to 60+ integrations in weeks, syncing tens of millions of jobs a month without breaking a sweat.

---

## Part 1: Nango Account Setup

### Step 1: Create Nango Account

1. Go to [nango.dev](https://nango.dev) and sign up
2. Create a new project named "AxiomIQ"

### Step 2: Understand the Pricing

Nango now offers transparent, usage-based pricing starting at $50/month. Pricing scales with usage: connections, action executions & record syncs. Volume discounts up to 100x included. 1,000 free connections still available on the Free plan.

**For MVP Development:**
- Free tier: 1,000 connections (plenty for development and early customers)
- Growth tier: $50/month base + usage-based pricing

### Step 3: Get Your Secret Key

In the Nango Dashboard:
1. Go to **Environment Settings**
2. Copy your **Secret Key** â†’ `NANGO_SECRET_KEY` (keep this private, backend only)

**Note:** Nango no longer uses public keys. The new model uses short-lived session tokens generated by your backend, which is more secure.

---

## Part 2: Configure Your First Integrations

### Step 1: Add Integrations in Nango Dashboard

Go to **Integrations** tab and add the integrations you need:

**Recommended Starting Set for AxiomIQ:**

| Integration | Category | Use Case |
|-------------|----------|----------|
| Gmail | Email | Send emails, read inbox |
| Google Calendar | Productivity | Schedule meetings |
| Slack | Messaging | Send notifications |
| HubSpot | CRM | Lead management |
| Notion | Productivity | Documentation |
| Linear | Project Management | Issue tracking |
| Stripe | Billing | Payment processing |

### Step 2: Configure OAuth Apps

For each OAuth integration, you need to create an OAuth app with the provider:

#### Example: Gmail/Google Setup

Go to APIs & Services > Credentials in the Google Cloud Console. Click Create Credentials and select OAuth client ID.

1. **Create Google Cloud Project**
   - Go to [console.cloud.google.com](https://console.cloud.google.com)
   - Create new project: "AxiomIQ Integrations"

2. **Enable Required APIs**
   - Gmail API
   - Google Calendar API
   - Google Sheets API

3. **Configure OAuth Consent Screen**
   - Go to APIs & Services â†’ OAuth consent screen
   - Choose "External" user type
   - Fill in app name, support email, etc.
   - Add scopes you need

4. **Create OAuth Credentials**
   - Go to APIs & Services â†’ Credentials
   - Click "Create Credentials" â†’ "OAuth client ID"
   - Application type: "Web application"
   - **Authorized redirect URI**: `https://api.nango.dev/oauth/callback`

5. **Add to Nango**
   - In Nango Dashboard â†’ Integrations â†’ Google (or Gmail)
   - Enter Client ID and Client Secret
   - Configure scopes:
     ```
     https://www.googleapis.com/auth/gmail.send
     https://www.googleapis.com/auth/gmail.readonly
     https://www.googleapis.com/auth/calendar
     ```

#### Example: Slack Setup

1. **Create Slack App**
   - Go to [api.slack.com/apps](https://api.slack.com/apps)
   - Click "Create New App" â†’ "From scratch"
   - Name: "AxiomIQ"
   - Pick workspace

2. **Configure OAuth**
   - Go to OAuth & Permissions
   - Add Redirect URL: `https://api.nango.dev/oauth/callback`
   - Add Bot Token Scopes:
     ```
     chat:write
     channels:read
     users:read
     ```

3. **Add to Nango**
   - In Nango Dashboard â†’ Integrations â†’ Slack
   - Enter Client ID and Client Secret from Slack app
   - Configure scopes

#### Example: HubSpot Setup

1. **Create HubSpot App**
   - Go to [developers.hubspot.com](https://developers.hubspot.com)
   - Create app
   - Go to Auth settings

2. **Configure OAuth**
   - Redirect URL: `https://api.nango.dev/oauth/callback`
   - Required scopes:
     ```
     crm.objects.contacts.read
     crm.objects.contacts.write
     crm.objects.deals.read
     crm.objects.deals.write
     ```

3. **Add to Nango**
   - Enter Client ID and Client Secret
   - Configure scopes

---

## Part 3: Next.js Integration

### Step 1: Install Dependencies

```bash
pnpm add @nangohq/node @nangohq/frontend
```

### Step 2: Environment Variables

Add to `.env.local`:

```bash
# Nango (only secret key needed - no public key!)
NANGO_SECRET_KEY=your-secret-key-here
```

**Note:** Nango deprecated public keys in January 2025. The new secure model uses session tokens generated by your backend.

### Step 3: Backend - Session Token Generation

Create `app/api/nango/session/route.ts`:

```typescript
import { Nango } from '@nangohq/node';
import { auth } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';

const nango = new Nango({ secretKey: process.env.NANGO_SECRET_KEY! });

export async function POST(request: Request) {
  try {
    // Get authenticated user from Clerk
    const { userId, orgId } = await auth();
    
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Parse request body for allowed integrations
    const body = await request.json();
    const { allowedIntegrations } = body;

    // Create Nango Connect session
    // The end_user.id should be your tenant ID (orgId or userId)
    const session = await nango.createConnectSession({
      end_user: {
        id: orgId || userId, // Use org ID if in org context, else user ID
        email: '', // Will be populated by Clerk user data
        display_name: '',
      },
      // Optionally filter which integrations the user can connect
      allowed_integrations: allowedIntegrations || undefined,
      // Tags help you organize connections
      organization: orgId ? { id: orgId } : undefined,
    });

    return NextResponse.json({ sessionToken: session.data.token });
  } catch (error) {
    console.error('Error creating Nango session:', error);
    return NextResponse.json(
      { error: 'Failed to create session' },
      { status: 500 }
    );
  }
}
```

### Step 4: Backend - Webhook Handler

Create `app/api/webhooks/nango/route.ts`:

```typescript
import { NextResponse } from 'next/server';
import { createServiceRoleClient } from '@/lib/supabase/server';

// Nango webhook payload types
interface NangoAuthWebhook {
  type: 'auth';
  connectionId: string;
  providerConfigKey: string;
  provider: string;
  environment: 'dev' | 'prod';
  success: boolean;
  operation: 'creation' | 'override' | 'unknown';
  error?: string;
  endUser?: {
    endUserId: string;
    organizationId?: string;
  };
}

export async function POST(request: Request) {
  try {
    const payload: NangoAuthWebhook = await request.json();
    
    // Only process successful auth events
    if (payload.type !== 'auth' || !payload.success) {
      return NextResponse.json({ received: true });
    }

    const supabase = createServiceRoleClient();
    
    // Determine owner (org or user)
    const ownerId = payload.endUser?.organizationId || payload.endUser?.endUserId;
    
    if (!ownerId) {
      console.error('No owner ID in Nango webhook');
      return NextResponse.json({ error: 'Missing owner ID' }, { status: 400 });
    }

    // Upsert the integration connection
    const { error } = await supabase
      .from('integrations')
      .upsert({
        owner_id: ownerId,
        provider: payload.providerConfigKey,
        nango_connection_id: payload.connectionId,
        status: 'active',
        connected_at: new Date().toISOString(),
      }, {
        onConflict: 'owner_id,provider',
      });

    if (error) {
      console.error('Error saving integration:', error);
      return NextResponse.json({ error: 'Database error' }, { status: 500 });
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Nango webhook error:', error);
    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 });
  }
}
```

### Step 5: Frontend - Integration Connection Component

Create `components/integrations/connect-integration.tsx`:

```typescript
'use client';

import { useState } from 'react';
import Nango from '@nangohq/frontend';
import { Button } from '@/components/ui/button';
import { useToast } from '@/components/ui/use-toast';

interface ConnectIntegrationProps {
  integrationId: string;
  integrationName: string;
  onSuccess?: (connectionId: string) => void;
}

export function ConnectIntegration({
  integrationId,
  integrationName,
  onSuccess,
}: ConnectIntegrationProps) {
  const [isConnecting, setIsConnecting] = useState(false);
  const { toast } = useToast();

  const handleConnect = async () => {
    setIsConnecting(true);

    try {
      // 1. Get session token from your backend
      const sessionRes = await fetch('/api/nango/session', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          allowedIntegrations: [integrationId],
        }),
      });

      if (!sessionRes.ok) {
        throw new Error('Failed to create session');
      }

      const { sessionToken } = await sessionRes.json();

      // 2. Initialize Nango with session token
      const nango = new Nango({
        connectSessionToken: sessionToken,
      });

      // 3. Open Connect UI
      const connect = nango.openConnectUI({
        onEvent: (event) => {
          if (event.type === 'connect') {
            // User successfully connected
            toast({
              title: 'Connected!',
              description: `Successfully connected to ${integrationName}`,
            });
            onSuccess?.(event.payload.connectionId);
          } else if (event.type === 'close') {
            // User closed the modal
            setIsConnecting(false);
          }
        },
      });

    } catch (error) {
      console.error('Connection error:', error);
      toast({
        title: 'Connection Failed',
        description: 'Could not connect to the integration. Please try again.',
        variant: 'destructive',
      });
    } finally {
      setIsConnecting(false);
    }
  };

  return (
    <Button onClick={handleConnect} disabled={isConnecting}>
      {isConnecting ? 'Connecting...' : `Connect ${integrationName}`}
    </Button>
  );
}
```

### Step 6: Frontend - Integrations Page

Create `app/dashboard/integrations/page.tsx`:

```typescript
import { createClerkSupabaseServerClient } from '@/lib/supabase/server';
import { ConnectIntegration } from '@/components/integrations/connect-integration';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';

// Available integrations configuration
const AVAILABLE_INTEGRATIONS = [
  {
    id: 'gmail',
    name: 'Gmail',
    description: 'Send and read emails',
    category: 'Email',
    icon: 'ðŸ“§',
  },
  {
    id: 'google-calendar',
    name: 'Google Calendar',
    description: 'Manage calendar events',
    category: 'Productivity',
    icon: 'ðŸ“…',
  },
  {
    id: 'slack',
    name: 'Slack',
    description: 'Send notifications and messages',
    category: 'Messaging',
    icon: 'ðŸ’¬',
  },
  {
    id: 'hubspot',
    name: 'HubSpot',
    description: 'CRM and lead management',
    category: 'CRM',
    icon: 'ðŸŽ¯',
  },
  {
    id: 'notion',
    name: 'Notion',
    description: 'Documentation and wikis',
    category: 'Productivity',
    icon: 'ðŸ“',
  },
  {
    id: 'linear',
    name: 'Linear',
    description: 'Issue tracking and project management',
    category: 'Project Management',
    icon: 'ðŸ“‹',
  },
];

export default async function IntegrationsPage() {
  const supabase = await createClerkSupabaseServerClient();
  
  // Get existing connections
  const { data: connections } = await supabase
    .from('integrations')
    .select('*')
    .eq('status', 'active');

  const connectedProviders = new Set(connections?.map(c => c.provider) || []);

  return (
    <div className="space-y-8">
      <div>
        <h1 className="text-3xl font-bold">Integrations</h1>
        <p className="text-muted-foreground">
          Connect your tools to power your workflows
        </p>
      </div>

      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {AVAILABLE_INTEGRATIONS.map((integration) => {
          const isConnected = connectedProviders.has(integration.id);
          
          return (
            <Card key={integration.id}>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <span className="text-2xl">{integration.icon}</span>
                    <div>
                      <CardTitle className="text-lg">{integration.name}</CardTitle>
                      <CardDescription>{integration.description}</CardDescription>
                    </div>
                  </div>
                  {isConnected && (
                    <Badge variant="secondary" className="bg-green-100 text-green-800">
                      Connected
                    </Badge>
                  )}
                </div>
              </CardHeader>
              <CardContent>
                <div className="flex items-center justify-between">
                  <Badge variant="outline">{integration.category}</Badge>
                  {isConnected ? (
                    <Button variant="outline" size="sm">
                      Manage
                    </Button>
                  ) : (
                    <ConnectIntegration
                      integrationId={integration.id}
                      integrationName={integration.name}
                    />
                  )}
                </div>
              </CardContent>
            </Card>
          );
        })}
      </div>
    </div>
  );
}
```

---

## Part 4: Using Integrations in Workflows

### Backend - Nango Proxy for API Calls

Create `lib/nango/client.ts`:

```typescript
import { Nango } from '@nangohq/node';

const nango = new Nango({ secretKey: process.env.NANGO_SECRET_KEY! });

export { nango };

// Helper to make authenticated API calls through Nango
export async function nangoProxy<T = any>(params: {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  endpoint: string;
  providerConfigKey: string;
  connectionId: string;
  data?: any;
  headers?: Record<string, string>;
}): Promise<T> {
  const response = await nango.proxy({
    method: params.method,
    endpoint: params.endpoint,
    providerConfigKey: params.providerConfigKey,
    connectionId: params.connectionId,
    data: params.data,
    headers: params.headers,
  });

  return response.data as T;
}

// Check if a connection is valid
export async function checkConnection(
  providerConfigKey: string,
  connectionId: string
): Promise<boolean> {
  try {
    await nango.getConnection(providerConfigKey, connectionId);
    return true;
  } catch {
    return false;
  }
}

// Get raw access token (if needed for custom API calls)
export async function getAccessToken(
  providerConfigKey: string,
  connectionId: string
): Promise<string | null> {
  try {
    const connection = await nango.getConnection(providerConfigKey, connectionId);
    return connection.credentials.access_token || null;
  } catch {
    return null;
  }
}
```

### Example: Gmail Tool for Agents

Create `lib/tools/gmail.ts`:

```typescript
import { nangoProxy } from '@/lib/nango/client';
import { tool } from 'ai';
import { z } from 'zod';

// Get connection ID for the current tenant
async function getGmailConnectionId(ownerId: string): Promise<string | null> {
  const supabase = createServiceRoleClient();
  const { data } = await supabase
    .from('integrations')
    .select('nango_connection_id')
    .eq('owner_id', ownerId)
    .eq('provider', 'gmail')
    .eq('status', 'active')
    .single();
  
  return data?.nango_connection_id || null;
}

// Tool: Send Email
export const sendEmailTool = (ownerId: string) => tool({
  description: 'Send an email using Gmail',
  parameters: z.object({
    to: z.string().describe('Recipient email address'),
    subject: z.string().describe('Email subject'),
    body: z.string().describe('Email body (can include HTML)'),
  }),
  execute: async ({ to, subject, body }) => {
    const connectionId = await getGmailConnectionId(ownerId);
    
    if (!connectionId) {
      return { success: false, error: 'Gmail not connected' };
    }

    try {
      // Gmail API expects base64 encoded email
      const email = [
        `To: ${to}`,
        `Subject: ${subject}`,
        'Content-Type: text/html; charset=utf-8',
        '',
        body,
      ].join('\r\n');

      const encodedEmail = Buffer.from(email).toString('base64url');

      await nangoProxy({
        method: 'POST',
        endpoint: '/gmail/v1/users/me/messages/send',
        providerConfigKey: 'gmail',
        connectionId,
        data: { raw: encodedEmail },
      });

      return { success: true, message: `Email sent to ${to}` };
    } catch (error) {
      return { success: false, error: `Failed to send email: ${error}` };
    }
  },
});

// Tool: Search Emails
export const searchEmailsTool = (ownerId: string) => tool({
  description: 'Search for emails in Gmail',
  parameters: z.object({
    query: z.string().describe('Gmail search query (e.g., "from:john subject:meeting")'),
    maxResults: z.number().optional().default(10).describe('Maximum number of results'),
  }),
  execute: async ({ query, maxResults }) => {
    const connectionId = await getGmailConnectionId(ownerId);
    
    if (!connectionId) {
      return { success: false, error: 'Gmail not connected' };
    }

    try {
      const response = await nangoProxy<{ messages: Array<{ id: string }> }>({
        method: 'GET',
        endpoint: `/gmail/v1/users/me/messages?q=${encodeURIComponent(query)}&maxResults=${maxResults}`,
        providerConfigKey: 'gmail',
        connectionId,
      });

      // Get full message details for each result
      const messages = await Promise.all(
        (response.messages || []).map(async (msg) => {
          const full = await nangoProxy<any>({
            method: 'GET',
            endpoint: `/gmail/v1/users/me/messages/${msg.id}`,
            providerConfigKey: 'gmail',
            connectionId,
          });

          const headers = full.payload?.headers || [];
          return {
            id: full.id,
            subject: headers.find((h: any) => h.name === 'Subject')?.value,
            from: headers.find((h: any) => h.name === 'From')?.value,
            date: headers.find((h: any) => h.name === 'Date')?.value,
            snippet: full.snippet,
          };
        })
      );

      return { success: true, messages };
    } catch (error) {
      return { success: false, error: `Failed to search emails: ${error}` };
    }
  },
});
```

### Example: Slack Tool for Agents

Create `lib/tools/slack.ts`:

```typescript
import { nangoProxy } from '@/lib/nango/client';
import { tool } from 'ai';
import { z } from 'zod';

export const sendSlackMessageTool = (ownerId: string) => tool({
  description: 'Send a message to a Slack channel',
  parameters: z.object({
    channel: z.string().describe('Channel name (e.g., #general) or channel ID'),
    message: z.string().describe('Message to send'),
  }),
  execute: async ({ channel, message }) => {
    const connectionId = await getSlackConnectionId(ownerId);
    
    if (!connectionId) {
      return { success: false, error: 'Slack not connected' };
    }

    try {
      await nangoProxy({
        method: 'POST',
        endpoint: '/api/chat.postMessage',
        providerConfigKey: 'slack',
        connectionId,
        data: {
          channel: channel.startsWith('#') ? channel.slice(1) : channel,
          text: message,
        },
      });

      return { success: true, message: `Message sent to ${channel}` };
    } catch (error) {
      return { success: false, error: `Failed to send Slack message: ${error}` };
    }
  },
});
```

### Example: HubSpot Tool for Agents

Create `lib/tools/hubspot.ts`:

```typescript
import { nangoProxy } from '@/lib/nango/client';
import { tool } from 'ai';
import { z } from 'zod';

export const createHubSpotContactTool = (ownerId: string) => tool({
  description: 'Create a new contact in HubSpot CRM',
  parameters: z.object({
    email: z.string().describe('Contact email address'),
    firstName: z.string().optional().describe('First name'),
    lastName: z.string().optional().describe('Last name'),
    company: z.string().optional().describe('Company name'),
    phone: z.string().optional().describe('Phone number'),
  }),
  execute: async ({ email, firstName, lastName, company, phone }) => {
    const connectionId = await getHubSpotConnectionId(ownerId);
    
    if (!connectionId) {
      return { success: false, error: 'HubSpot not connected' };
    }

    try {
      const properties: Record<string, string> = { email };
      if (firstName) properties.firstname = firstName;
      if (lastName) properties.lastname = lastName;
      if (company) properties.company = company;
      if (phone) properties.phone = phone;

      const response = await nangoProxy({
        method: 'POST',
        endpoint: '/crm/v3/objects/contacts',
        providerConfigKey: 'hubspot',
        connectionId,
        data: { properties },
      });

      return { success: true, contactId: response.id };
    } catch (error) {
      return { success: false, error: `Failed to create contact: ${error}` };
    }
  },
});

export const searchHubSpotContactsTool = (ownerId: string) => tool({
  description: 'Search for contacts in HubSpot CRM',
  parameters: z.object({
    query: z.string().describe('Search query (searches email, name, company)'),
    limit: z.number().optional().default(10).describe('Maximum results'),
  }),
  execute: async ({ query, limit }) => {
    const connectionId = await getHubSpotConnectionId(ownerId);
    
    if (!connectionId) {
      return { success: false, error: 'HubSpot not connected' };
    }

    try {
      const response = await nangoProxy({
        method: 'POST',
        endpoint: '/crm/v3/objects/contacts/search',
        providerConfigKey: 'hubspot',
        connectionId,
        data: {
          query,
          limit,
          properties: ['email', 'firstname', 'lastname', 'company', 'phone'],
        },
      });

      return { success: true, contacts: response.results };
    } catch (error) {
      return { success: false, error: `Failed to search contacts: ${error}` };
    }
  },
});
```

---

## Part 5: Database Schema for Integrations

Add this to your Supabase migrations:

```sql
-- Integrations table (connected OAuth accounts)
CREATE TABLE IF NOT EXISTS integrations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    owner_id TEXT NOT NULL,  -- Clerk org ID or user ID
    provider VARCHAR(100) NOT NULL,  -- gmail, slack, hubspot, etc.
    nango_connection_id VARCHAR(255) NOT NULL,
    status VARCHAR(50) DEFAULT 'active',  -- active, expired, revoked
    scopes TEXT[],
    connected_by TEXT,  -- User who connected
    connected_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ,
    metadata JSONB DEFAULT '{}',
    UNIQUE(owner_id, provider)
);

ALTER TABLE integrations ENABLE ROW LEVEL SECURITY;

-- Users can view their own integrations
CREATE POLICY "Users can view their integrations"
ON integrations FOR SELECT
TO authenticated
USING (owner_id = requesting_owner_id());

-- Users can manage their own integrations
CREATE POLICY "Users can manage their integrations"
ON integrations FOR ALL
TO authenticated
USING (owner_id = requesting_owner_id());

-- Service role for webhooks
CREATE POLICY "Service role can manage integrations"
ON integrations FOR ALL
TO service_role
USING (true);

-- Index for faster lookups
CREATE INDEX idx_integrations_owner_provider 
ON integrations(owner_id, provider);
```

---

## Part 6: Configure Nango Webhooks

### Step 1: Set Up Webhook in Nango Dashboard

1. Go to **Environment Settings** â†’ **Webhooks**
2. Add webhook URL: `https://axiomiq.app/api/webhooks/nango`
3. Select events:
   - `auth` - Connection created/updated
   - `sync` - Data sync completed (if using syncs)

### Step 2: Verify Webhook Signatures (Production)

Update your webhook handler to verify signatures:

```typescript
import crypto from 'crypto';

function verifyNangoWebhook(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload)
    .digest('hex');
  
  return crypto.timingSafeEqual(
    Buffer.from(signature),
    Buffer.from(expectedSignature)
  );
}

export async function POST(request: Request) {
  const signature = request.headers.get('x-nango-signature');
  const body = await request.text();
  
  if (!verifyNangoWebhook(body, signature!, process.env.NANGO_WEBHOOK_SECRET!)) {
    return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
  }
  
  const payload = JSON.parse(body);
  // ... rest of handler
}
```

---

## Part 7: Testing Your Integration

### Step 1: Test in Nango Dashboard

On the Nango integration page, click Add Connection to test the authorization. After authorizing API access for one of the modes described below, a connection should be successfully created in the Connections tab.

### Step 2: Test from Your App

1. Start your dev server: `pnpm dev`
2. Navigate to `/dashboard/integrations`
3. Click "Connect Gmail"
4. Complete the OAuth flow
5. Verify the connection appears in:
   - Nango Dashboard â†’ Connections
   - Your Supabase `integrations` table

### Step 3: Test API Calls

Create a test endpoint `app/api/test/gmail/route.ts`:

```typescript
import { nangoProxy } from '@/lib/nango/client';
import { auth } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';
import { createClerkSupabaseServerClient } from '@/lib/supabase/server';

export async function GET() {
  const { orgId, userId } = await auth();
  const ownerId = orgId || userId;
  
  const supabase = await createClerkSupabaseServerClient();
  const { data: integration } = await supabase
    .from('integrations')
    .select('nango_connection_id')
    .eq('owner_id', ownerId)
    .eq('provider', 'gmail')
    .single();

  if (!integration) {
    return NextResponse.json({ error: 'Gmail not connected' }, { status: 400 });
  }

  // Test: Get user's Gmail profile
  const profile = await nangoProxy({
    method: 'GET',
    endpoint: '/gmail/v1/users/me/profile',
    providerConfigKey: 'gmail',
    connectionId: integration.nango_connection_id,
  });

  return NextResponse.json({ profile });
}
```

---

## Summary: What You Get

After completing this setup:

âœ… **OAuth for 500+ APIs** - Gmail, Slack, HubSpot, etc. all handled
âœ… **Automatic Token Refresh** - Nango keeps credentials valid
âœ… **White-Label UI** - Users don't see Nango branding
âœ… **Credential Security** - Tokens stored securely by Nango
âœ… **Webhook Notifications** - Know when connections fail
âœ… **Multi-Tenant Ready** - Each org has isolated connections
âœ… **Agent-Ready Tools** - Pre-built tools for your AI agents

---

## Quick Reference: Environment Variables

```bash
# Nango (only one key needed!)
NANGO_SECRET_KEY=xxxx          # Backend only - get from Nango Dashboard
NANGO_WEBHOOK_SECRET=xxxx      # Optional: For webhook signature verification
```

**Note:** Public keys are deprecated. Use session tokens instead (already implemented in the code above).

---

## Next Steps

1. [ ] Create Nango account and get API keys
2. [ ] Set up your first OAuth app (start with Gmail)
3. [ ] Add the integrations table to Supabase
4. [ ] Implement the session and webhook API routes
5. [ ] Build the integrations page UI
6. [ ] Test the full OAuth flow
7. [ ] Create tools for your agents to use the integrations

Would you like me to help you set up a specific integration (Gmail, Slack, HubSpot, etc.) in more detail?
